<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Texas Hold'em — Bots & Custom Setup</title>
<style>
  :root{--bg:#0f3b2d;--panel:#fff;--accent:#2b9348}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;background:var(--bg);color:#fff}
  header{padding:14px;background:linear-gradient(90deg,#093;#0b6);text-align:center}
  h1{margin:0;font-size:20px;color:#012}
  main{display:flex;flex-wrap:wrap;gap:16px;padding:16px;justify-content:center}
  .card{background:#fff;color:#000;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
  #setup{min-width:320px;max-width:420px}
  label{display:block;margin:8px 0 4px;font-weight:600}
  input[type=number], select, input[type=text]{width:100%;padding:8px;border-radius:6px;border:1px solid #ccc}
  button{padding:10px 14px;border-radius:8px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  #table{min-width:320px;max-width:900px}
  .seats{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-bottom:12px}
  .seat{width:160px;background:rgba(255,255,255,.06);padding:8px;border-radius:8px;min-height:72px}
  .name{font-weight:700}
  .cards{margin-top:8px}
  .card-face{display:inline-block;padding:6px 8px;border-radius:6px;margin-right:6px;background:#fff;color:#000;font-weight:700}
  .community{display:flex;gap:8px;justify-content:center;margin:10px 0}
  .big{font-size:18px}
  #controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #log{max-height:220px;overflow:auto;background:#111;color:#eee;padding:8px;border-radius:8px;font-size:13px}
  .small{font-size:13px;color:#444}
  .chip{background:gold;padding:4px 8px;border-radius:8px;font-weight:700}
  .muted{color:#666}
  @media (max-width:640px){.seat{width:48%}}
</style>
</head>
<body>
<header><h1>Texas Hold'em — Vs Bots (Custom Setup)</h1></header>
<main>
  <section id="setup" class="card">
    <h2>Table Setup</h2>
    <label>Buy-in (starting chips)</label>
    <input id="buyin" type="number" min="10" value="1000">
    <label>Small Blind</label>
    <input id="sblind" type="number" min="1" value="10">
    <label>Big Blind</label>
    <input id="bblind" type="number" min="2" value="20">
    <label>Number of bots (1–7)</label>
    <input id="botcount" type="number" min="1" max="7" value="3">
    <div id="bot-settings" class="small muted" style="margin-top:8px">Set each bot difficulty after hitting <b>Update Bots</b></div>
    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="updateBotsBtn">Update Bots</button>
      <button id="startBtn">Start Game</button>
    </div>
    <div style="margin-top:12px">
      <label>Raise amount (when you click Raise)</label>
      <input id="raiseAmt" type="number" min="1" value="50">
      <label style="margin-top:8px">Player name</label>
      <input id="playerName" type="text" placeholder="Your name" value="You">
    </div>
  </section>

  <section id="table" class="card" style="width:640px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><span class="muted small">Pot:</span> <span class="chip" id="pot">0</span></div>
      <div><span class="muted small">Dealer:</span> <span id="dealerPos">—</span></div>
      <div><span class="muted small">To act:</span> <span id="toAct">—</span></div>
    </div>

    <div class="community" id="community"></div>

    <div class="seats" id="seats"></div>

    <div id="controls" style="margin-top:10px">
      <button id="foldBtn">Fold</button>
      <button id="callBtn">Call</button>
      <button id="raiseBtn">Raise</button>
      <input id="raiseInput" type="number" min="1" value="50" style="width:110px;padding:8px;border-radius:6px">
      <button id="nextHandBtn">Next Hand (force)</button>
    </div>

    <div style="margin-top:12px">
      <label class="small muted">Hand Log</label>
      <div id="log"></div>
    </div>
  </section>

  <section id="handsRef" class="card" style="max-width:340px">
    <h3>Poker Hands (high → low)</h3>
    <ol style="padding-left:18px;margin:6px 0">
      <li>Royal Flush</li>
      <li>Straight Flush</li>
      <li>Four of a Kind</li>
      <li>Full House</li>
      <li>Flush</li>
      <li>Straight</li>
      <li>Three of a Kind</li>
      <li>Two Pair</li>
      <li>One Pair</li>
      <li>High Card</li>
    </ol>
    <div style="margin-top:8px">
      <label>Bot difficulties</label>
      <div id="botSelects"></div>
      <div class="small muted" style="margin-top:8px">Hard bots can bluff occasionally.</div>
    </div>
  </section>
</main>

<script>
/* ---------- Utilities & Card Engine ---------- */
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const SUITS = ['♠','♥','♦','♣'];

function createDeck(){
  const d=[];
  for(const r of RANKS) for(const s of SUITS) d.push(r+s);
  return d;
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
}
function cardRankValue(card){
  const r = card.slice(0, card.length-1);
  return RANKS.indexOf(r);
}
function cardPretty(card){ return card; }

/* returns array of best hand descriptor object for comparison */
function evaluateHand(sevenCards){
  // brute-force: check all 5-card combos; compute rank tuple for comparison
  const combos = k_combinations(sevenCards,5);
  let best = null;
  for(const combo of combos){
    const v = rank5(combo);
    if(!best || cmpRankTuple(v.tuple,best.tuple) > 0) best = v;
  }
  return best;
}
function k_combinations(set, k){
  const results=[];
  function comb(start, cur){
    if(cur.length===k) return results.push(cur.slice());
    for(let i=start;i<set.length;i++){ cur.push(set[i]); comb(i+1,cur); cur.pop(); }
  }
  comb(0,[]);
  return results;
}
function cmpRankTuple(a,b){
  // returns positive if a > b
  for(let i=0;i<a.length;i++){
    if(a[i] !== b[i]) return a[i] - b[i];
  }
  return 0;
}

/* rank5: given 5 cards, returns {name, tuple} where tuple is numeric tuple for comparison */
function rank5(cards){
  // convert to ranks numeric (2->0 ... A->12)
  const ranks = cards.map(c=>cardRankValue(c)).sort((a,b)=>a-b);
  const counts = {}; for(const r of ranks) counts[r]=(counts[r]||0)+1;
  const countsArr = Object.entries(counts).map(([r,c])=>({r:+r,c})).sort((a,b)=>b.c - a.c || b.r - a.r);
  const isFlush = cards.map(c=>c.slice(-1)).every(s=>s===cards[0].slice(-1));
  // check straight (including wheel A-2-3-4-5)
  let distinct = Array.from(new Set(ranks)).sort((a,b)=>a-b);
  let isStraight=false, highStraight=-1;
  if(distinct.length===5){
    if(distinct[4]-distinct[0]===4){ isStraight=true; highStraight=distinct[4]; }
    // wheel?
    if(JSON.stringify(distinct)==JSON.stringify([0,1,2,3,12])){ isStraight=true; highStraight=3; } // treat 5-high straight highest rank 3 (value 5)
  }
  // Determine hand category (higher tuple components => stronger)
  // tuple structure: [categoryRank, primary, secondary, kicker...]
  // categoryRank: 9=RoyalFlush,8=StraightFlush,7=Four,6=FullHouse,5=Flush,4=Straight,3=Trips,2=TwoPair,1=Pair,0=HighCard
  if(isFlush && isStraight){
    if(highStraight===12) return {name:'Royal Flush', tuple:[9,12]}; // highest possible
    return {name:'Straight Flush', tuple:[8,highStraight]};
  }
  if(countsArr[0].c===4){
    // four of a kind
    const four = countsArr[0].r;
    const kicker = countsArr[1].r;
    return {name:'Four of a Kind', tuple:[7,four,kicker]};
  }
  if(countsArr[0].c===3 && countsArr[1] && countsArr[1].c===2){
    // full house
    return {name:'Full House', tuple:[6,countsArr[0].r,countsArr[1].r]};
  }
  if(isFlush){
    // sort ranks desc for kickers
    const desc = ranks.slice().sort((a,b)=>b-a);
    return {name:'Flush', tuple:[5,...desc]};
  }
  if(isStraight){
    return {name:'Straight', tuple:[4,highStraight]};
  }
  if(countsArr[0].c===3){
    const trips = countsArr[0].r;
    const kickers = countsArr.slice(1).map(x=>x.r).sort((a,b)=>b-a);
    return {name:'Three of a Kind', tuple:[3,trips,...kickers]};
  }
  if(countsArr[0].c===2 && countsArr[1] && countsArr[1].c===2){
    const pairHigh = Math.max(countsArr[0].r, countsArr[1].r);
    const pairLow = Math.min(countsArr[0].r, countsArr[1].r);
    const kicker = countsArr[2].r;
    return {name:'Two Pair', tuple:[2,pairHigh,pairLow,kicker]};
  }
  if(countsArr[0].c===2){
    const pair = countsArr[0].r;
    const kickers = countsArr.slice(1).map(x=>x.r).sort((a,b)=>b-a);
    return {name:'One Pair', tuple:[1,pair,...kickers]};
  }
  // high card
  const desc = ranks.slice().sort((a,b)=>b-a);
  return {name:'High Card', tuple:[0,...desc]};
}

/* ---------- Game State & Bot Logic ---------- */
let game = null;

function resetGameState(){
  return {
    players: [], // {id,name,isBot,diff,stack,hand,hasFolded,actedThisRound,betThisRound}
    deck: [],
    community: [],
    pot: 0,
    dealerIndex: 0,
    sb: 10,
    bb: 20,
    currentBet: 0,
    toActIndex: 0,
    round: 'idle' // 'preflop','flop','turn','river','showdown'
  };
}

function log(msg){
  const ln = document.createElement('div');
  ln.textContent = msg;
  document.getElementById('log').prepend(ln);
}

/* Bot decision helper: basic hand strength estimate using evaluateHand tuple */
function handStrengthEstimate(player, community){
  // returns number roughly proportional to strength: larger = better
  const seven = player.hand.concat(community);
  const ev = evaluateHand(seven);
  // compress tuple to numeric score
  const t = ev.tuple;
  let score = t[0]*1e6;
  for(let i=1;i<t.length;i++){ score += t[i]*Math.pow(100, -i+1) * 1000; }
  return score;
}

/* Bot action: returns {action:'fold'|'call'|'raise', amt:... } */
function botDecide(bot, state){
  const diff = bot.difficulty; // 'Easy','Medium','Hard'
  const callAmt = state.currentBet - bot.betThisRound;
  // random tendencies
  if(diff==='Easy'){
    // 20% raise small, else call or fold randomly
    const r = Math.random();
    if(r < 0.15 && bot.stack > callAmt + 20) return {action:'raise', amt: Math.min(bot.stack, callAmt + 20)};
    if(r < 0.7) return {action: (callAmt<=0?'call':'call'), amt: callAmt};
    return {action:'fold', amt:0};
  }
  if(diff==='Medium'){
    // estimate strength vs threshold
    const str = handStrengthEstimate(bot, state.community);
    // threshold tuned empirically
    if(str > 8.5e6 && bot.stack > callAmt + 50) return {action:'raise', amt: Math.min(bot.stack, callAmt + 40)};
    if(str > 4.5e6) return {action:'call', amt: callAmt};
    if(Math.random()<0.25) return {action:'call', amt: callAmt};
    return {action:'fold', amt:0};
  }
  // Hard: evaluate stronger, sometimes bluff
  if(diff==='Hard'){
    const str = handStrengthEstimate(bot, state.community);
    // bluff probability
    const bluff = Math.random() < 0.08; // 8% bluff
    if(bluff && bot.stack > callAmt + 80) return {action:'raise', amt: Math.min(bot.stack, callAmt + 80)};
    if(str > 7e6){
      // strong -> raise more often
      if(bot.stack > callAmt + 80 && Math.random()<0.5) return {action:'raise', amt: Math.min(bot.stack, callAmt + 80)};
      return {action:'call', amt: callAmt};
    }
    if(str > 4e6){
      if(Math.random()<0.6) return {action:'call', amt: callAmt};
      return {action:'fold', amt:0};
    }
    // weak hand: sometimes call small
    if(callAmt===0) return {action:'call', amt:0};
    if(callAmt <= Math.min(20, bot.stack) && Math.random()<0.3) return {action:'call', amt: callAmt};
    return {action:'fold', amt:0};
  }
  return {action:'fold', amt:0};
}

/* ---------- UI Wiring & Core Gameplay ---------- */
let state = resetGameState();

function buildBotSelects(count){
  const container = document.getElementById('botSelects');
  container.innerHTML = '';
  for(let i=0;i<count;i++){
    const div = document.createElement('div');
    div.style.marginTop='6px';
    div.innerHTML = `<label>Bot ${i+1}:</label>
      <select id="botdiff${i}"><option>Easy</option><option selected>Medium</option><option>Hard</option></select>`;
    container.appendChild(div);
  }
}

document.getElementById('updateBotsBtn').onclick = ()=>{
  const cnt = parseInt(document.getElementById('botcount').value)||1;
  buildBotSelects(cnt);
  document.getElementById('bot-settings').textContent = 'Set difficulties and then Start Game.';
};

document.getElementById('startBtn').onclick = ()=>{
  startGame();
};

document.getElementById('nextHandBtn').onclick = ()=>{ startHand(); };

document.getElementById('foldBtn').onclick = ()=>{ playerAction('fold'); };
document.getElementById('callBtn').onclick = ()=>{ playerAction('call'); };
document.getElementById('raiseBtn').onclick = ()=>{ 
  const val = parseInt(document.getElementById('raiseInput').value) || 0;
  if(val<=0){ alert('Enter raise amount'); return; }
  playerAction('raise', val);
};

function startGame(){
  // init players
  const buyin = Math.max(1, parseInt(document.getElementById('buyin').value)||1000);
  const sb = Math.max(1, parseInt(document.getElementById('sblind').value)||10);
  const bb = Math.max(sb*2, parseInt(document.getElementById('bblind').value)||20);
  const botCount = Math.min(7, Math.max(1, parseInt(document.getElementById('botcount').value)||3));
  const pname = document.getElementById('playerName').value || 'You';
  state = resetGameState();
  state.sb = sb; state.bb = bb;
  // human player seat 0
  state.players.push({
    id:'human',
    name:pname,
    isBot:false,
    difficulty:'Human',
    stack:buyin,
    hand:[],
    hasFolded:false,
    betThisRound:0
  });
  for(let i=0;i<botCount;i++){
    const sel = document.getElementById(`botdiff${i}`);
    const diff = sel ? sel.value : 'Medium';
    state.players.push({
      id:'bot'+(i+1),
      name:'Bot'+(i+1),
      isBot:true,
      difficulty:diff,
      stack:buyin,
      hand:[],
      hasFolded:false,
      betThisRound:0
    });
  }
  state.dealerIndex = 0; // dealer initial
  renderSeats();
  log('Game started. Buy-in '+buyin+' | SB:'+sb+' BB:'+bb+' | Bots:'+botCount);
  startHand();
}

function renderSeats(){
  const seats = document.getElementById('seats'); seats.innerHTML='';
  state.players.forEach((p, idx)=>{
    const el = document.createElement('div'); el.className='seat';
    el.innerHTML = `<div class="name">${p.name} ${state.dealerIndex===idx?'<span class="muted small"> (D)</span>':''}</div>
      <div class="small muted">Stack: <b>${p.stack}</b></div>
      <div class="small muted">Bet: <span id="bet${idx}">${p.betThisRound||0}</span></div>
      <div class="cards" id="cards${idx}">${p.hand.map(c=>'<span class="card-face">'+(p.isBot ? (p.isBot && p.id!=='human' ? '??' : c) : c)+'</span>').join('')}</div>`;
    seats.appendChild(el);
  });
  document.getElementById('pot').textContent = state.pot;
  document.getElementById('dealerPos').textContent = state.players[state.dealerIndex] ? state.players[state.dealerIndex].name : '—';
}

function startHand(){
  // reset per-hand
  state.deck = createDeck(); shuffle(state.deck);
  state.community = [];
  state.pot = 0;
  state.currentBet = 0;
  state.players.forEach(p => { p.hand=[]; p.hasFolded=false; p.betThisRound=0; p.actedThisRound=false; });
  // post blinds: small = dealer+1, big = dealer+2
  const sbPos = (state.dealerIndex+1) % state.players.length;
  const bbPos = (state.dealerIndex+2) % state.players.length;
  const sbPlayer = state.players[sbPos], bbPlayer = state.players[bbPos];
  // ensure they have chips
  const sbAmt = Math.min(state.sb, sbPlayer.stack); sbPlayer.stack -= sbAmt; sbPlayer.betThisRound += sbAmt; state.pot += sbAmt;
  const bbAmt = Math.min(state.bb, bbPlayer.stack); bbPlayer.stack -= bbAmt; bbPlayer.betThisRound += bbAmt; state.pot += bbAmt;
  state.currentBet = bbAmt;
  log(`Hand started. SB posted by ${sbPlayer.name} (${sbAmt}), BB by ${bbPlayer.name} (${bbAmt}).`);
  // deal hole cards
  for(let i=0;i<2;i++){
    for(let p of state.players) p.hand.push(state.deck.pop());
  }
  // set toAct to player after big blind
  state.toActIndex = (bbPos+1) % state.players.length;
  state.round = 'preflop';
  renderCommunity();
  renderSeats();
  updateToActDisplay();
  // If first to act is a bot, run bot loop
  runActionLoop();
}

function renderCommunity(){
  const cont = document.getElementById('community'); cont.innerHTML='';
  state.community.forEach(c=>{
    const s = document.createElement('div'); s.className='card-face'; s.textContent=c; cont.appendChild(s);
  });
  document.getElementById('pot').textContent = state.pot;
}

function updateToActDisplay(){ document.getElementById('toAct').textContent = state.players[state.toActIndex] ? state.players[state.toActIndex].name : '—'; }

function runActionLoop(){
  // if current actor is bot -> perform bot action then advance until human needs to play or hand finished
  // check if only one active player remains -> end hand
  const activePlayers = state.players.filter(p=>!p.hasFolded && p.stack+ p.betThisRound > 0);
  if(activePlayers.length<=1){
    // award pot to remaining
    const winner = state.players.find(p=>!p.hasFolded);
    if(winner){ winner.stack += state.pot; log(`${winner.name} wins uncontested pot of ${state.pot}`); }
    state.pot=0; renderSeats(); renderCommunity();
    advanceDealer();
    return;
  }
  const cur = state.players[state.toActIndex];
  if(!cur) return;
  if(cur.isBot){
    // bot decides
    const decision = botDecide(cur, state);
    performAction(cur, decision.action, decision.amt);
    // pause slightly for realism
    setTimeout(()=>{
      // advance to next active player
      advanceToNextActive();
      renderSeats(); renderCommunity(); updateToActDisplay();
      // check if betting round complete: simple rule — if everyone's acted and bets equal or only one left, progress
      if(isBettingRoundComplete()) proceedRound();
      else runActionLoop();
    }, 500 + Math.random()*600);
  } else {
    // human: enable controls
    enableControls(true);
  }
}

function performAction(player, action, amt){
  amt = amt || 0;
  const idx = state.players.indexOf(player);
  if(action==='fold'){
    player.hasFolded = true; log(`${player.name} folds.`);
  } else if(action==='call'){
    const toCall = state.currentBet - player.betThisRound;
    const pay = Math.min(player.stack, toCall);
    player.stack -= pay; player.betThisRound += pay; state.pot += pay;
    player.actedThisRound = true;
    log(`${player.name} calls ${pay}.`);
  } else if(action==='raise'){
    // player wants to raise by amt (total bet becomes player.betThisRound + amt)
    const toCall = state.currentBet - player.betThisRound;
    const totalPut = toCall + amt;
    const pay = Math.min(player.stack, totalPut);
    player.stack -= pay; player.betThisRound += pay; state.pot += pay;
    state.currentBet = player.betThisRound;
    // mark others as needing to act again
    state.players.forEach(p=>p.actedThisRound = (p===player));
    log(`${player.name} raises to ${player.betThisRound}.`);
  } else {
    // treat unknown as check
    player.actedThisRound = true;
    log(`${player.name} checks.`);
  }
  renderSeats(); renderCommunity();
}

function playerAction(action, raiseVal){
  const player = state.players[0]; if(player.hasFolded) return;
  enableControls(false);
  if(action==='fold'){ performAction(player,'fold'); advanceToNextActive(); }
  else if(action==='call'){ performAction(player,'call'); advanceToNextActive(); }
  else if(action==='raise'){ performAction(player,'raise', raiseVal || (parseInt(document.getElementById('raiseInput').value)||0)); advanceToNextActive(); }
  // reset acted flags for players who acted
  renderSeats(); renderCommunity(); updateToActDisplay();
  if(isBettingRoundComplete()) proceedRound();
  else runActionLoop();
}

function enableControls(enable){
  document.getElementById('foldBtn').disabled = !enable;
  document.getElementById('callBtn').disabled = !enable;
  document.getElementById('raiseBtn').disabled = !enable;
  document.getElementById('raiseInput').disabled = !enable;
}

/* Advance to next player who hasn't folded and still has chips (or at least acted) */
function advanceToNextActive(){
  let i = state.toActIndex;
  const n = state.players.length;
  for(let step=1;step<=n;step++){
    const idx = (i+step)%n;
    const p = state.players[idx];
    if(!p.hasFolded && (p.stack>0 || p.betThisRound < state.currentBet)) { state.toActIndex = idx; return; }
  }
  // fallback: just advance by one
  state.toActIndex = (state.toActIndex+1)%n;
}

/* Are betting rounds complete? (all active players have acted and bets equal) */
function isBettingRoundComplete(){
  const active = state.players.filter(p=>!p.hasFolded);
  // if any active player hasn't acted this round -> not complete
  if(active.some(p=>!p.actedThisRound)) return false;
  // all bets equal? ignoring all-in mismatches for simplicity
  const betVals = new Set(active.map(p=>p.betThisRound));
  return betVals.size <= 1;
}

function proceedRound(){
  // reset acted flags and bets (bets remain for pot)
  state.players.forEach(p=>p.actedThisRound=false);
  // move from preflop -> flop -> turn -> river -> showdown
  if(state.round==='preflop'){
    // reveal flop (3)
    state.community.push(state.deck.pop(), state.deck.pop(), state.deck.pop());
    state.round='flop';
    log('Flop: '+state.community.join(' '));
  } else if(state.round==='flop'){
    state.community.push(state.deck.pop()); state.round='turn';
    log('Turn: '+state.community.join(' '));
  } else if(state.round==='turn'){
    state.community.push(state.deck.pop()); state.round='river';
    log('River: '+state.community.join(' '));
  } else if(state.round==='river'){
    state.round='showdown';
    handleShowdown(); return;
  }
  // prepare next betting round: reset each player's betThisRound to 0 and currentBet to 0 for simplicity
  state.players.forEach(p=>p.betThisRound=0);
  state.currentBet = 0;
  // toAct = first active after dealer
  state.toActIndex = (state.dealerIndex + 1) % state.players.length;
  updateToActDisplay(); renderCommunity(); renderSeats(); runActionLoop();
}

function handleShowdown(){
  // evaluate all non-folded players and choose best
  const contenders = state.players.filter(p=>!p.hasFolded);
  let bestPlayer=null, bestEval=null;
  for(const p of contenders){
    const evalRes = evaluateHand(p.hand.concat(state.community));
    log(`${p.name} shows ${p.hand.join(' ')} → ${evalRes.name}`);
    if(!bestEval || cmpRankTuple(evalRes.tuple,bestEval.tuple) > 0){
      bestEval = evalRes; bestPlayer = p;
    }
  }
  if(bestPlayer){
    bestPlayer.stack += state.pot;
    log(`${bestPlayer.name} wins pot ${state.pot} with ${bestEval.name}`);
  } else {
    log('No winner found (weird).');
  }
  state.pot = 0;
  renderSeats(); renderCommunity();
  advanceDealer();
}

function advanceDealer(){
  // advance dealer, check for bankrupt players removal (or keep them with 0)
  state.dealerIndex = (state.dealerIndex + 1) % state.players.length;
  // reset for next hand
  // small housekeeping: remove players with 0 stack? keep them but they can't bet
  renderSeats();
  updateToActDisplay();
  // automatically start next hand after short delay if human still has chips
  const human = state.players[0];
  if(human && human.stack>0){
    setTimeout(()=>{ startHand(); }, 1200);
  } else {
    log('Game over (you are bust). Refresh to start new game.');
  }
}

/* ---------- Initial UI Setup ---------- */
buildBotSelects(parseInt(document.getElementById('botcount').value));
renderSeats();
log('Ready. Configure table then click Start Game.');

/* Expose evaluate for debugging (optional) */
window._debug = {evaluateHand, rank5};
</script>
</body>
</html>
